# Raspberry Pi 64bit Stuff

## Boards

Databox is recommending R-Pi 3B+
- w. BCM2837B0 (1.4GHz) quad-core ARM Cortex A53 (ARMv8) cluster
- i.e. Armv8-A architecture
- Two execution states: AArch32 (to execute existing Armv7-A applications) and AArch64 (used by databox)
- Note, all general purpose Arm v8 devices have hardware FP support

## R-Pi Boot

See [docs](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/bootflow.md)

Defaults to SD card then USB (mass-storage devices then n/w DHCP/TFTP). 
Configurable via OTP (one-time programmable) to (also) use GPIO to select boot modes.
- checks each of the boot sources for a file called bootcode.bin
- finds first FAT partition (used to have to be first partition, can be FAT16 or FAT32)
- ("also supports GUID partitioning"?)
- (some other stuff about booting from the USB OTG interface)

According to [this](https://raspberrypi.stackexchange.com/questions/10442/what-is-the-boot-sequence), 
after bootcode.bin we get:
- load and run start.bin, which load start.elf
- start.elf loads kernel.img
- It then also reads config.txt, cmdline.txt and bcm2835.dtb (optional)
- kernel.img is then run on the ARM.

More details [here](https://wiki.beyondlogic.org/index.php?title=Understanding_RaspberryPi_Boot_Process).
Including extra kernel parameter examples. 

Note, needs config.txt option "arm_control=0x200" to boot as ARMv8 mode.

Note, all ARM linux kernels must use Device Tree to specify board-specific characteristics. 
I.e. there is a (binarised) configuration file that specifies to the kernel exactly what set of devices/drivers the particular board has that it is booting on.
This is passed to the kernel by the bootloader on boot.

R-Pi 2 and later use a different kernel & initramfs to earlier 
64 bit version (obviously) only supports r-pi 3b/+

The files in the boot partition seem to be generated by "pi-gen", at least in Raspbian.
Pre-compiled files (probably 32 bit) available to download from github.

## Alpine

Databox is using Alpine 64 bit (aarch64) as default host.

### John's instructions

John Moore's [instructions](https://gist.github.com/jptmoore/3830592d6e21f26a5b68181f47e141ed) to set up alpine/r-pi/docker for databox:
```
setup-alpine *don't set a repo; do enable eth0 with dhcp*
lbu commit -d
setup-apkrepos
apk update
apk upgrade
lbu commit -d
rc-update add swclock boot
rc-update del hwclock boot
lbu commit -d
*edit /etc/ssh/sshd_config and set PermitRootLogin yes*
/etc/init.d/sshd restart
passwd *reset your password*
*ssh in to carry on*
apk add e2fsprogs
mkfs.ext4 /dev/mmcblk0p2
mount /dev/mmcblk0p2 /mnt
setup-disk -m sys /mnt
mount -o remount,rw /dev/mmcblk0p1
rm /media/mmcblk0p1/boot/*
mv /mnt/boot/* /media/mmcblk0p1/boot
cd /mnt
rm boot/boot
rmdir boot
mkdir media/mmcblk0p1
ln -s media/mmcblk0p1 boot
echo "/dev/mmcblk0p1 /media/mmcblk0p1 vfat defaults 0 0" >> etc/fstab
sed -i '/cdrom/d' etc/fstab
sed -i '/floppy/d' etc/fstab
sed -i '/edge/!s/^#//' etc/apk/repositories
cd /media/mmcblk0p1
sed -i 's/^/root=\/dev\/mmcblk0p2 /' cmdline.txt
reboot
*some optional things you might want*
fallocate -l 2G /mnt/2GB.swap
mkswap /mnt/2GB.swap
swapon /mnt/2GB.swap
echo "/mnt/2GB.swap  none  swap  sw 0  0" >> /etc/fstab
echo "vm.swappiness=10" >> /etc/sysctl.conf
chmod 600 /mnt/2GB.swap
rc-update add swap boot
apk -U add haveged && rc-service haveged start && rc-update add haveged
apk add git
apk add docker
rc-update add docker boot
service docker start
```
This mostly follows the [Alping r-pi](https://wiki.alpinelinux.org/wiki/Raspberry_Pi)
instructions for a standard disk based installation. 
Doesn't use (restore system from) provided apkovl file, but including e2fsprogs is perhaps the only difference that would result?
Moves new root /boot content onto FAT boot partition.
Removes default cdrom/floppy/edge mounts. 
Adds swap, haveged, docker.


### Background / exploration

General: alpine has own package manager, apk

[Alping r-pi](https://wiki.alpinelinux.org/wiki/Raspberry_Pi)
The default for this uses diskless mode (see below), plus alpine local backup to keep changes.
Instructions are given for a standard disk-based install (sys mode, see below), with the warning that 
"This isn't yet supported by the Alpine setup scripts for Raspberry Pi. It requires manual intervention, and might break".
This uses a FAT32 boot partition and a ext4 root partition on the memory card:
- following a normal set-up process, creating an lbu backup (apkovl)
- create the ext4 filesystem
- run setup-disk on it with the apkovl file
- (ignore errors about syslinux/extlinux bootloaders, which are not used on r-pi)
- setup FAT partition to mount in fstab, optionally with /boot on /boot aswell (root FS /boot is not used)
- setup ext4 partition (device) to be root in r-pi bootloader cmdline file
- reboot :-)
- (note that updating the boot image, etc., needs to update the FAT32 partition version, not the /boot created on the ext4 partition)

By default alpine uses the syslinux bootloader.
But for r-pi it uses the standard r-pi arrangement with bootcode.bin and start.elf.

Alpine [installation basics](https://wiki.alpinelinux.org/wiki/Installation). 
Note, alpine is typically installed from a CD-ROM (diskless) version on that machine, and this supports various install modes:
- "diskless", can use "alpine local backup" (lbu) to store ("commit") changes (to /etc) on same medium
- "data" mode, runs OS readonly, but mounts a writable partition on /var
- "sys" mode, i.e. standard disk-based with (default) /boot, / and swap partitions (manually configurable)

Typically setup-alpine is run on a new install to set hostname, etc. 
But depending on the options it will also do an install from a diskless boot onto the disk of the machine (sys mode, above).

Check out the init ram fs (made by mkinitfs), which is a gzipped cpio archive:
```
mkdir tmp
cd tmp
zcat /vagrant/alpine-rpi-3.8.2-aarch64/boot/initramfs-rpi | cpio -idm
```
/init from initramfs is run when kernel starts; it actually handles the kernel parameters.
In the diskless version it will install packages and generally set up the linux machine in the ram fs.
Note that this limits the amount of stuff you can install (which usually goes into /usr or /opt) because of RAM size.
Note that in data mode (like diskless mode) this will still happen every time the machine boots; 
the only real difference is mounting a writable partition on /var.

Possibly useful parameters include:
- ssh_key=... - URL or path (?) of ssh public key for remote login (or place in /root/.ssh/authorized_keys)
- ip=dhcp - enable DHCP on first available network interface
- apkovl=PATH - apkovl file (i.e. tgz) to install

Note, can generate SSH key with `ssh-keygen -t rsa`

See /sbin/setup-disk for handling of /var. Note that contents of /var are moved into new partition, syslog is restarted (and something is done with mdadm =? RAID).
But if new (encrypted) /var is set up and (also) mounted before setup-disk is run (which for r-pi uses custom disk layout for sys install) then no worries...?

Files to fix:
- /etc/hostname - hostname
- /etc/network/interfaces - interfaces to enable, e.g.
```
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
        hostname alpine

```
- /root/.ssh/authorized_keys - ssh public key for remote access
- start networking?

### Init

[docs](https://wiki.alpinelinux.org/wiki/Alpine_Linux_Init_System) - 
uses [OpenRC init system](https://wiki.gentoo.org/wiki/OpenRC).

Run-levels: default, hotplugged, manual; (internal) sysinit, boot (hotplugged), single, reboot, shutdown

Script format documented in [openrc-run](https://manpages.debian.org/testing/openrc/openrc-run.8.en.html)

Main dependency: `need` (other service name(s))

Looks like dependcy can be overruled in /etc/conf.d/SERVICE by setting (e.g.) rc_need.

Note, hotplugged services are started when associated dynamic device manager detects device. 

### docker

```
sudo apk add docker
sudo rc-update add docker boot
sudo service docker start
sudo docker version
sudo docker run hello-world
```

Docker is installed in boot runlevel. 
By default docker needs sysfs, cgroups (only)

Docker files are all (by default) in /var/lib/docker (logs in /var/log/docker*)

### Encryption

[set up disks](https://wiki.alpinelinux.org/wiki/Setting_up_disks_manually) ... 
has section on Encryption. 
points [here](https://wiki.alpinelinux.org/wiki/Setting_up_encrypted_volumes_with_LUKS)

There are instructions for encrypted root using kernel parameters, e.g. cryptroot=/dev/md1 and cryptdm=crypt.
Also a suggestion to create/add an entry to crypttab suggesting in might be supported (as opposed to config in /etc/conf.d/dmcrypt).

[cryptsetup](https://gitlab.com/cryptsetup/cryptsetup) "is utility used to conveniently setup disk encryption based
on DMCrypt kernel module", i.e. device mapper crypt module. 
"LUKS is the standard for Linux hard disk encryption."

Device mapper crypt module takes a block device (partition) and maps it to a new block device, but with encryption/decrypytion automatically applied.
The mapping must be established each time the encrypted device is to be used, and of course requires the key.
With luks this is called opening the device.
A file system is created on the mapped device.
The mapped device can then be mounted and used.
The mapping step can read the encrypyion key (or, for luks, passphrase) from another file, which obviously must be accessible at that point.

Is/can be persisted in crypttab, which will be set-up on boot. Passwords there are filepaths. Failure by default is a boot failure.

Try out on a file... [following](https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#2-setup)
```
sudo apk update
sudo apk upgrade
sudo apk add cryptsetup

head -c 100m /dev/zero > luksfile  # create empty file
sudo losetup -a
sudo losetup /dev/loop0 luksfile        # map luksfile to /dev/loop0
sudo cryptsetup luksFormat /dev/loop0   # create LUKS on loop device
# passphrase
sudo cryptsetup luksDump /dev/loop0
sudo cryptsetup luksOpen /dev/loop0 crypt
# passphrase
sudo mke2fs -t ext4 /dev/mapper/crypt
sudo mkdir /mnt/crypt
sudo mount /dev/mapper/crypt /mnt/crypt
ls -l /mnt/crypt
sudo mkdir test
sudo chown vagrant test
cd test
...
sudo umount /mnt/crypt
sudo cryptsetup luksClose crypt

```

service seems to be 'dmcrypt' (see init)
```
rc-update add dmcrypt boot
```
before checkfs, fsck. 
So not after localmount?! So would only work with a file on the (already mounted) root filesystem, or an actual block device?!

Also add mapped volume to /etc/fstab. That should happen in localmount.

But is that enough to make it happen before docker. Not convinced! 
Perhaps /etc/conf.d/docker "rc_need localmount" would be OK?

Swap and tmp should probably also be encrypted?! and/or tmp moved to ramdisk?
See also [this](https://wiki.archlinux.org/index.php/Dm-crypt/Swap_encryption).
Better to make swap an encrypted partition or file?
Note, random encrypted swap prevents suspend/resume; but [apparently](https://www.raspberrypi.org/forums/viewtopic.php?t=202067) r-pis can't suspend anyway.

### USB fiddling

```
sudo apt-get install usbutils
lsusb
```

## Raspbian boot image

The image file:
```
Disk /dev/loop0: 1780 MB, 1866465280 bytes, 3645440 sectors
226 cylinders, 255 heads, 63 sectors/track
Units: sectors of 1 * 512 = 512 bytes

Device     Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size I
d Type
/dev/loop0p1    0,130,3     6,26,18           8192      98045      89854 43.8M
c Win95 FAT32 (LBA)
/dev/loop0p2    6,30,25     226,234,8        98304    3645439    3547136 1732M 8
3 Linux

```
The SD card itself:
```
Disk /dev/sdb: 29 GB, 31657558016 bytes, 61831168 sectors
30191 cylinders, 64 heads, 32 sectors/track
Units: sectors of 1 * 512 = 512 bytes

Device  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id T
ype
/dev/sdb1    0,130,3     6,26,18           8192      98045      89854 43.8M  c W
in95 FAT32 (LBA)
/dev/sdb2    6,30,25     1023,254,63      98304   61831167   61732864 29.4G 83 L
inux
```
Turns out geometry is meaningless/arbitrary on modern devices (even disks which have geometry).

A dd copy back from the SD card written from the above by etcher:
```
Disk /dev/loop1: 4 MB, 4194304 bytes, 8192 sectors
0 cylinders, 255 heads, 63 sectors/track
Units: sectors of 1 * 512 = 512 bytes

Device     Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size I
d Type
/dev/loop1p1    0,130,3     6,26,18           8192      98045      89854 43.8M
c Win95 FAT32 (LBA)
/dev/loop1p2    6,30,25     1023,254,63      98304   61831167   61732864 29.4G 8
3 Linux
```


## Disk image

I'll work in Alpine (x64) for now.

Let makes a file that will be the SD card image, 201MB for now.

I've tried several times to do this from scratch straight onto an image file but for some reason I haven't got Windows or R-Pi to recognise it as a valid file-system.
So I've switched to doing the initial set-up on a real SD card, taking an image of that and then I can do stuff OK. 
Not sure why...

Insert SD card (ready to be wiped!)
```
sudo fdisk -l
```
Assuming it comes up as /dev/sdb...

```
sudo fdisk /dev/sdb
```
fdisk partition - one for now, FAT32, like raspbian:
```
# new empty dos partition table
o
# new partition
n
# primary
p
# no. 1
1
# first sector like raspbian
8192
# size - boot starts at about 50MB of files; rest- try 200MB for now, ends at 411647
411647
# (not bootable - like raspbian) a, 1
# change system type
t
# Hex code (partition 1, win95 FAT32 (LBA) like raspbian = c)
c
# write
w
```
Create filesystem
```
sudo apk add dosfstools
sudo mkdosfs -F 32 -S 1024 /dev/sdb1 201728
```
Optional: to work on the FAT partition on the real SD card:
```
sudo mkdir -p /mnt/sd1
sudo mount -t vfat /dev/sdb1 /mnt/sd1
df -k
sudo umount /mnt/sd1
```

Make base image now:
```
sudo dd if=/deb/sdb of=rpi64boot.img bs=1024
```

To work on the FAT partition in the image file (starts at sector 8192, byte 4194304):
```
sudo losetup -f -o 4194304 rpi64boot.img
sudo losetup -a
```
assuming it is /dev/loop0...
```
sudo mount -t vfat /dev/loop0 /mnt/sd1
```

Install initial boot files...
Get boot files, from [downloads](https://alpinelinux.org/downloads/), specifically
```
wget http://dl-cdn.alpinelinux.org/alpine/v3.8/releases/aarch64/alpine-rpi-3.8.2-aarch64.tar.gz
(cd /mnt/sd1; sudo tar zxf ~/rpiboot/alpine-rpi-3.8.2-aarch64.tar.gz)
```
Uses about 50MB, 125MB free.
Fiddle some more?

E.g. if you have an .apkovl.tar.gz file (i.e. a tgz of files to install on top of the ram boot, typically stuff in /etc, then copy it to the top-level of FAT partition.

Done:
```
sudo umount /mnt/sd1
sudo losetup -d /dev/loop0
```

OK, try writing that to an SD Card with balena etcher or dd
```
sudo fdisk -l
```
Assuming on /dev/sdb

```
sudo dd if=rpi64boot.img of=/dev/sdb bs=1M
sudo eject /dev/sdb
```

Boot on r-pi model 3B+...

Do setup-alpine if you like

## notes for later

### ext4 FS:
```
sudo apk add e2fsprogs
sudo mke2fs -t ext4 -b 1024 /dev/loop1 204800
```

### full image from file

note got this to work (see above)
```
mkdir rpiboot
cd rpiboot
dd if=/dev/zero of=rpi64boot.img bs=1M count=201 
sudo losetup -f rpi64boot.img
sudo losetup -a
```
assuming it is on /dev/loop0...


### extra partitions

in fdisk...
```
# second partition - for sys install
n
# primary
p
# partition
2
# first sector 
411648
# size - also 200MB for now? (ends at 821247)
+200M
# change system type
t
# partition
2
# Hex code (partition 1, win95 FAT32)
b
# one more - would be encrypted?!
n
p
3
821248
+200M
```
