# Raspberry Pi 64bit Stuff

## Boards

Databox is recommending R-Pi 3B+
- w. BCM2837B0 (1.4GHz) quad-core ARM Cortex A53 (ARMv8) cluster
- i.e. Armv8-A architecture
- Two execution states: AArch32 (to execute existing Armv7-A applications) and AArch64 (used by databox)
- Note, all general purpose Arm v8 devices have hardware FP support

## R-Pi Boot

See [docs](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bootmodes/bootflow.md)

Defaults to SD card then USB (mass-storage devices then n/w DHCP/TFTP). 
Configurable via OTP (one-time programmable) to (also) use GPIO to select boot modes.
- checks each of the boot sources for a file called bootcode.bin
- finds first FAT partition (used to have to be first partition, can be FAT16 or FAT32)
- ("also supports GUID partitioning"?)
- (some other stuff about booting from the USB OTG interface)

According to [this](https://raspberrypi.stackexchange.com/questions/10442/what-is-the-boot-sequence), 
after bootcode.bin we get:
- load and run start.bin, which load start.elf
- start.elf loads kernel.img
- It then also reads config.txt, cmdline.txt and bcm2835.dtb (optional)
- kernel.img is then run on the ARM.

More details [here](https://wiki.beyondlogic.org/index.php?title=Understanding_RaspberryPi_Boot_Process).
Including extra kernel parameter examples. 

Note, needs config.txt option "arm_control=0x200" to boot as ARMv8 mode.

Note, all ARM linux kernels must use Device Tree to specify board-specific characteristics. 
I.e. there is a (binarised) configuration file that specifies to the kernel exactly what set of devices/drivers the particular board has that it is booting on.
This is passed to the kernel by the bootloader on boot.

R-Pi 2 and later use a different kernel & initramfs to earlier 
64 bit version (obviously) only supports r-pi 3b/+

The files in the boot partition seem to be generated by "pi-gen", at least in Raspbian.
Pre-compiled files (probably 32 bit) available to download from github.

## Alpine

Databox is using Alpine 64 bit (aarch64) as default host.

General: alpine has own package manager, apk

[Alping r-pi](https://wiki.alpinelinux.org/wiki/Raspberry_Pi)

By default alpine uses the syslinux bootloader.
But for r-pi it uses the standard r-pi arrangement with bootcode.bin and start.elf.

[installation basic](https://wiki.alpinelinux.org/wiki/Installation). Note, various modes:
- "diskless", can use "alpine local backup" (lbu) to store ("commit") changes (to /etc) on same medium
- "data" mode, runs OS readonly, but mounts a writable partition on /var
- "sys" mode, i.e. standard disk-based with (default) /boot, / and swap partitions (manually configurable)

sorted by setup-alpine, post install (?) script

### Encryption

[set up disks](https://wiki.alpinelinux.org/wiki/Setting_up_disks_manually) ... 
has section on Encryption. 
points [here](https://wiki.alpinelinux.org/wiki/Setting_up_encrypted_volumes_with_LUKS)

There are instructions for encrypted root using kernel parameters, e.g. cryptroot=/dev/md1 and cryptdm=crypt.
Also a suggestion to create/add an entry to crypttab suggesting in might be supported (c.f /etc/conf.d/dmcrypt).

[cryptsetup](https://gitlab.com/cryptsetup/cryptsetup) "is utility used to conveniently setup disk encryption based
on DMCrypt kernel module", i.e. device mapper crypt module. 
"LUKS is the standard for Linux hard disk encryption."

Device mapper crypt module takes a block device (partition) and maps it to a new block device, but with encryption/decrypytion automatically applied.
The mapping must be established each time the encrypted device is to be used, and of course requires the key.
With luks this is called opening the device.
A file system is created on the mapped device.
The mapped device can then be mounted and used.
The mapping step can read the encrypyion key (or, for luks, passphrase) from another file, which obviously must be accessible at that point.

Is/can be persisted in crypttab, which will be set-up on boot. Passwords there are filepaths. Failure by default is a boot failure.

Try out on a file... [following](https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#2-setup)
```
sudo apk update
sudo apk upgrade
sudo apk add cryptsetup

head -c 100m /dev/zero > luksfile  # create empty file
sudo losetup -a
sudo losetup /dev/loop0 luksfile        # map luksfile to /dev/loop0
sudo cryptsetup luksFormat /dev/loop0   # create LUKS on loop device
# passphrase
sudo cryptsetup luksDump /dev/loop0
sudo cryptsetup luksOpen /dev/loop0 crypt
# passphrase
sudo mke2fs -t ext4 /dev/mapper/crypt
sudo mkdir /mnt/crypt
sudo mount /dev/mapper/crypt /mnt/crypt
ls -l /mnt/crypt
sudo mkdir test
sudo chown vagrant test
cd test
...
sudo umount /mnt/crypt
sudo cryptsetup luksClose crypt

```

service seems to be 'dmcrypt' (see init)
```
rc-update add dmcrypt boot
```
before checkfs, fsck. 
So not after localmount?! So would only work with a file on the (already mounted) root filesystem, or an actual block device?!

Also add mapped volume to /etc/fstab. That should happen in localmount.

But is that enough to make it happen before docker. Not convinced! 
Perhaps docker needs localmount would be OK?

### Init

[docs](https://wiki.alpinelinux.org/wiki/Alpine_Linux_Init_System) - 
uses [OpenRC init system](https://wiki.gentoo.org/wiki/OpenRC).

Run-levels: default, hotplugged, manual; (internal) sysinit, boot (hotplugged), single, reboot, shutdown

Script format documented in [openrc-run](https://manpages.debian.org/testing/openrc/openrc-run.8.en.html)

Main dependency: `need` (other service name(s))

Looks like dependcy can be overruled in /etc/conf.d/SERVICE by setting (e.g.) rc_need.

Note, hotplugged services are started when associated dynamic device manager detects device. 

### docker

```
sudo apk add docker
sudo rc-update add docker boot
sudo service docker start
sudo docker version
sudo docker run hello-world
```

Docker is installed in boot runlevel. 
By default docker needs sysfs, cgroups (only)

Docker files are all (by default) in /var/lib/docker (logs in /var/log/docker*)

### USB fiddling

```
sudo apt-get install usbutils
lsusb
```
